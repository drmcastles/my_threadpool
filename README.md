
# Custom Thread Pool Executor

Этот проект демонстрирует реализацию кастомного пула потоков на Java с поддержкой следующих функций: core и max размеров пула, индивидуальных очередей задач на воркера, балансировки задач (Round Robin), параметров keepAliveTime и minSpareThreads, ручного отклонения задач при переполнении, логирования и сравнения со стандартным `ThreadPoolExecutor`.

## Структура проекта

Проект состоит из двух основных классов:
- `CustomThreadPoolExecutor.java` — реализация пула потоков.
- `CustomThreadPoolExecutorDemo.java` — пример использования и сравнение с `ThreadPoolExecutor`.

## Основные возможности

- **corePoolSize / maxPoolSize** – количество начальных и максимальных потоков.
- **queueCapacity** – емкость очереди задач у каждого потока.
- **keepAliveTime** – время ожидания задачи перед завершением лишнего потока.
- **minSpareThreads** – минимальное количество "живых" потоков, даже при простое.
- **Round Robin** – распределение задач между очередями по кругу.
- **Отклонение задач** – если все очереди заполнены и потоков максимум, задача не принимается и логируется.

## Запуск

1. Убедитесь, что у вас установлен JDK 17+.
2. Скомпилируйте проект:
   ```
   javac -d out src/customexecutor/*.java
   ```
3. Запустите демонстрацию:
   ```
   java -cp out customexecutor.CustomThreadPoolExecutorDemo
   ```

## Пример вывода

```
[Pool] Создан новый воркер Worker-0
[Pool] Задача добавлена в очередь 0
[Pool] Все очереди заполнены, задача отклонена
[StandardPool] Задача 9 отклонена
Время выполнения кастомного пула: 30008 мс
```

## Параметры пула

Вы можете настроить параметры пула в `CustomThreadPoolExecutorDemo.java`:

```java
CustomThreadPoolExecutor customExecutor = new CustomThreadPoolExecutor(
    2,       // corePoolSize
    4,       // maxPoolSize
    3,       // queueCapacity
    5000,    // keepAliveTime
    TimeUnit.MILLISECONDS,
    1        // minSpareThreads
);
```

## Пример использования

```java
Runnable task = () -> {
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
};

boolean accepted = customExecutor.submit(task);
if (!accepted) {
    System.out.println("Задача отклонена");
}
```

## Анализ

В ходе тестирования пользовательский пул сравнивался со стандартным ThreadPoolExecutor из Java. В рамках одного и того же количества задач (10 задач по 3 секунды каждая) пользовательский пул показал большую гибкость масштабирования, однако потребовал большего времени выполнения из-за особенностей реализации балансировки и задержек между добавлением новых воркеров.

Пул	Время выполнения
CustomThreadPoolExecutor	~30 сек
Standard ThreadPoolExecutor	~2 сек

Тем не менее, пользовательский пул нацелен не столько на максимальную скорость, сколько на гибкость конфигурации и контролируемое масштабирование.

Тестирование параметров пула
Были проведены эксперименты с различными значениями следующих параметров:

corePoolSize

maxPoolSize

queueCapacity

keepAliveTime

minSpareThreads

Выводы:
Малый corePoolSize приводит к отложенному созданию дополнительных потоков, что замедляет старт обработки.

Большой maxPoolSize увеличивает масштабируемость, но только при достаточной queueCapacity.

Малый queueCapacity эффективно вызывает отказ задач и помогает в контроле нагрузки.

minSpareThreads > 0 гарантирует, что даже в состоянии простоя пул будет держать минимальное количество потоков, готовых к работе.

Распределение задач
Задачи распределяются между очередями воркеров по алгоритму Round Robin — по кругу, равномерно, чтобы избежать перегрузки одной очереди.

Пример:

makefile
Копировать
Редактировать
Задачи: T1 T2 T3 T4
Очереди: Q0 Q1 Q2 Q3
Распределение: T1 → Q0, T2 → Q1, T3 → Q2, T4 → Q3
Если все очереди заполнены, а пул достиг maxPoolSize, задача отклоняется, и это логируется в консоль:

[Pool] Все очереди заполнены, задача отклонена
